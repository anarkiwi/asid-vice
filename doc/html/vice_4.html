<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.52
     from vice.texi on 11 November 2022 -->

<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-15">
<TITLE>VICE Manual - 4  System files</TITLE>
<style type="text/css">
    @import 'vice.css';
</style>
</HEAD>
<BODY>
Go to the <A HREF="vice_1.html">first</A>, <A HREF="vice_3.html">previous</A>, <A HREF="vice_5.html">next</A>, <A HREF="vice_23.html">last</A> section, <A HREF="vice_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC25" HREF="vice_toc.html#TOC25">4  System files</A></H1>

<P>
In order to work properly, the emulators need to load a few system
files:

</P>

<UL>

<LI>

the <EM>system ROMs</EM>, raw binary files containing copies of the original ROMs
of the machine you are emulating;

<LI>

the <EM>keyboard maps</EM>, text files describing the keyboard layout;

<LI>

the <EM>palette files</EM>, text files describing the colors of the machine you
are emulating.

<LI>

the <EM>romset files</EM>, text files describing the different ROMs to load.

</UL>

<P>
The place where they will be searched for depends on the value of the
<CODE>Directory</CODE> resource, which is a colon (<CODE>:</CODE>)-separated search
path list, like the UNIX <CODE>PATH</CODE> environment variable.  The
default value is

</P>

<PRE>
$HOME/.local/share/vice/EMU:PREFIX/lib/vice/EMU:BOOTPATH/EMU
</PRE>

<P>
Where <CODE>PREFIX</CODE> is the installation prefix (usually
<TT>`/usr/local'</TT>), <CODE>EMU</CODE> is the name of the emulated machine
(<CODE>C64</CODE>, <CODE>C64DTV</CODE>, <CODE>C128</CODE>, <CODE>PET</CODE>,  <CODE>PLUS4</CODE>, <CODE>CBM-II</CODE>, <CODE>SCPU64</CODE>
or <CODE>VIC20</CODE>) and <CODE>BOOTPATH</CODE> is the directory where the executable resides.
The disk drive ROMs are looked for in a directory with <CODE>EMU</CODE> set to
<CODE>DRIVES</CODE>. <CODE>$HOME</CODE> is the user's home directory.

</P>
<P>
For example, if you have the C64 emulator installed in

</P>

<PRE>
/usr/local/bin/x64
</PRE>

<P>
then the value will be

</P>

<PRE>
$HOME/.local/share/vice/C64:/usr/local/lib/vice/C64:/usr/local/bin/C64
</PRE>

<P>
And system files will be searched for under the following directories,
in the specified order:

</P>

<OL>
<LI>

<CODE>$HOME/.local/share/vice/C64</CODE>
<LI>

<CODE>/usr/local/lib/VICE/C64</CODE>
<LI>

<CODE>/usr/local/bin/C64</CODE>
</OL>

<P>
System files can still be installed in a different directory if you
specify a complete path instead of just a file name.  For example, if
you specify <TT>`./kernal'</TT> as the kernal image name, the kernal image
will be loaded from the current directory.  This can be done by using
command-line options or by modifying resource values (see section <A HREF="vice_6.html#SEC55">6.1  Format of resource files</A>).

</P>



<H2><A NAME="SEC26" HREF="vice_toc.html#TOC26">4.1  ROM files</A></H2>

<P>
Every emulator requires its own ROM set.  For the VIC20 and the C64, the
ROM set consists of the following files:

</P>

<UL>

<LI>

<TT>`kernal'</TT>,  the Kernal ROM (8 KiB)

<LI>

<TT>`basic'</TT>, the Basic ROM (8 KiB)

<LI>

<TT>`chargen'</TT>, the character generator ROM (4 KiB)

</UL>

<P>
The C128 needs the following files:

</P>

<UL>

<LI>

<TT>`kernal'</TT>, the Kernal ROM (8 KiB)

<LI>

<TT>`basic'</TT>, the Basic + Editor ROM (32 KiB)

<LI>

<TT>`chargen'</TT>, the character generator ROM (4 KiB)

</UL>

<P>
The C128, VIC20, SCPU64 and C64 emulators also need the following DOS ROMs for
the hardware-level emulation of the 1540, 1541, 1571, 1581, 2000, and 4000 disk
drives, as well as the CMD hard drive:

</P>

<UL>

<LI>

<TT>`dos1540'</TT>, the 1540 drive ROM (16 KiB)

<LI>

<TT>`dos1541'</TT>, the 1541 drive ROM (16 KiB)

<LI>

<TT>`dos1541II'</TT>, the 1541-II drive ROM (16 KiB)

<LI>

<TT>`dos1571'</TT>, the 1571 drive ROM (32 KiB)

<LI>

<TT>`dos1581'</TT>, the 1581 drive ROM (32 KiB)

<LI>

<TT>`dos2000'</TT>, the 2000 drive ROM (32 KiB)

<LI>

<TT>`dos4000'</TT>, the 4000 drive ROM (32 KiB)

<LI>

<TT>`dosCMDHD'</TT>, the CMD HD boot ROM (16 KiB)

</UL>

<P>
In addition to those all emulators can handle
a parallel IEEE488 interface (the C64 and C128 via <CODE>$df**</CODE> extension,
the VIC20 via VIC1112 emulation)
so they also need the DOS ROM for the IEEE disk drives:

</P>

<UL>

<LI>

<TT>`dos2031'</TT>, the 2031 drive ROM (16 KiB)
(DOS 2.6, Commodore ROM images 901484-03 and 901484-05)

<LI>

<TT>`dos2040'</TT>, the 2040 drive ROM (8 KiB)
(DOS 1, Commodore ROM images 901468-06, 901468-07)

<LI>

<TT>`dos3040'</TT>, the 3040 drive ROM (12 KiB)
(DOS 2, Commodore ROM images 901468-11, 901468-12 and 901468-13)

<LI>

<TT>`dos4040'</TT>, the 4040 drive ROM (12 KiB)
(DOS 2, Commodore ROM images 901468-14, 901468-15 and 901468-16)

<LI>

<TT>`dos1001'</TT>, the 1001/8050/8250 drive ROM (16 KiB)
(DOS 2.7, Commodore ROM images 901887-01 and 901888-01)

<LI>

<TT>`dos9000'</TT>, the D9090/60 drive ROM (16 KiB)
(DOS 3.0, Commodore ROM images 300516-RevC and 300517-RevC)

</UL>

<P>
Note that there are other DOS images on the internet. The DOS 2.5 images
might be used with the 8050, but it cannot handle the double sided drives
of the 1001 and 8250 and it is not supported by VICE.

</P>
<P>
The PET emulator uses an expanded setup, because there are three major
versions of the Basic and the Kernal, and many versions of the
Editor ROM. In addition there are cartridge ROM sockets.

</P>
<P>
The Kernal files contain the memory from range $F000-$FFFF, the Basic
ROMs either the range $C000-$DFFF or $B000-$DFFF.
To handle the different screen
sizes and keyboards, different so-called "editor-ROMs" for the memory
range $E000-$E800 are provided.
The PET ROMs have the following names:

</P>

<UL>

<LI>

<TT>`kernal-1.901439-04-07.bin'</TT>, the PET2001 Kernal ROM (4 KiB)
(Commodore ROM images 901447-06 and 901447-07, same as 901439-04 and 901439-07)
<LI>

<TT>`kernal-2.901465-03.bin'</TT>, the PET3032 Kernal ROM (4 KiB)
(Commodore ROM image 901465-03)
<LI>

<TT>`kernal-4.901465-22.bin'</TT>, the PET4032/8032 Kernal ROM (4 KiB)
(Commodore ROM image 901465-22)

<LI>

<TT>`basic-1.901439-09-05-02-06.bin'</TT>, the PET2001 Basic 1 ROM (8 KiB)
(Commodore ROM images 901447-09, 901447-02, 901447-03, 901447-04.bin.
The -09 ROM is the revised -01 ROM.
Same as images 901439-09, 901439-05, 901439-02, 901439-06.
The -09 ROM is the revised -01 ROM)
<LI>

<TT>`basic-2.901465-01-02.bin'</TT>, the PET3032 Basic 2 ROM (8 KiB)
(Commodore ROM images 901465-01 and 901465-01)
<LI>

<TT>`basic-4.901465-23-20-21.bin'</TT>, the PET4032/8032 Basic 4 ROM (12 KiB)
(Commodore ROM images 901465-23, 901465-20 and 901465-21.
The -23 ROM is a revised -19 ROM)

<LI>

<TT>`edit-1-n.901439-03.bin'</TT>, the PET2001 editor for graphics keyboards (2 KiB)
(Commodore ROM image 901447-05, same as 901439-03)
<LI>

<TT>`edit-2-b.901474-01.bin'</TT>, the PET3032 editor for business keyboards (2 KiB)
(Commodore ROM image 901474-01)
<LI>

<TT>`edit-2-n.901447-24.bin'</TT>, the PET3032 editor for graphics keyboards (2 KiB)
(Commodore ROM image 901447-24)
<LI>

<TT>`edit-4-40-n-50Hz.901498-01.bi'</TT>, the PET4032 editor for graphics keyboards (2 KiB)
(Commodore ROM image 901498-01)
<LI>

<TT>`edit-4-40-b-50Hz.ts.bin'</TT>, the PET4032 editor for business keyboards (2 KiB)
(Said to be "901498-01 modified to use a business keyboard on a 50Hz 4032")

<LI>

<TT>`edit-4-80-b-50Hz.901474-04_.bin'</TT>, the PET8032 editor for business keyboards (2 KiB)
(Commodore ROM image 901474-04-?)

<LI>

<TT>`characters-2.901447-10.bin'</TT>, the character generator ROM (2KiB).
It has two sets
with 128 chars each.  The second (inverted) half of each set is computed from
the first half by inverting it.  This is a PET hardware feature.
(Commodore ROM image 901447-10)
<LI>

<TT>`chargen.de'</TT>, the character generator ROM (2KiB). This version is a
patched German charset, with the characters [, \ and ] replaced by umlauts.
It has been provided by U. Guettich and he reports that it is supported
by some programs.

<LI>

<TT>`characters.901640-01.bin'</TT>, the SuperPET character generator ROM (4KiB).
The first half is the same as <TT>`characters-2.901447-10.bin'</TT>, the second half contains,
instead of an upper and lower case set, an ASCII character set and an
APL character set. For these sets, the screen code is equal to the
ASCII/APL code.
<LI>

<TT>`waterloo-[abcdf]000.901898-0[1-5].bin'</TT>,
<TT>`waterloo-e000.901897-01.bin'</TT>.
The Waterloo system ROMs for the 6809 CPU in the SuperPET.

<LI>

<TT>`hre-9000.324992-02.bin'</TT> HiRes Emulator (at $9000) and
<TT>`hre-a000.324993-02.bin'</TT> HiRes BASIC (at $A000).
These are the two roms for supporting the HRE on the 8296.
The ROMs are initialized by the command <CODE>SYS 36864</CODE>.
</UL>

<P>
The PETs also have sockets for extension ROMs for the addresses
$9000-$9FFF, $A000-$AFFF and $B000-$BFFF (the last one for PET2001 and
PET3032 only).  You can specify ROM image files for those extensions
command line options <CODE>-petrom9</CODE>, <CODE>-petromA</CODE> and
<CODE>-petromB</CODE> resp.

</P>
<P>
An alternative would be to specify a long kernal ROM with the
<CODE>-kernal</CODE> option that includes the extension ROM areas.

</P>
<P>
Also, you can specify replacements for the basic ROM at $B000-$DFFF
with the <CODE>-petromBasic</CODE> option and for the editor ROM
at $E000-$E7FF with the <CODE>-petromEditor</CODE> option.

</P>
<P>
The CBM-II emulator again uses another setup.  For those models the
kernal used is the same for all.  However, for different amounts of
memory exist different versions of the BASIC ROMs.  The 128KiB RAM version
(C610, C710, B128) uses one bank of 64KiB for the BASIC text and another
one for all the variables.  The 256KiB RAM version uses one bank for text,
one for variables, one for arrays and one for strings.

</P>
<P>
Also the character generator ROMs have a format different from the
above.  The other character ROMs have 8 bytes of pixel data per
character.  Those ROMs have 16 bytes per character instead.  The C6x0
only uses the first 8 of it, but the C7x0 uses 14 lines per character
and needs those larger ROMs.  Both ROMs hold, like the PET, two
character sets with 128 characters each.  Again the second half of the
full (256 char) character set is computed by inverting.

</P>

<UL>

<LI>

<TT>`kernal'</TT>, the KERNAL (8KiB) for the business machines (6xx/7xx)

<LI>

<TT>`kernal.500'</TT>, the KERNAL (8KiB) for the personal machine (510) (901234-02)

<LI>

<TT>`basic.128'</TT>, the CBM-II 128KiB BASIC (16KiB)

<LI>

<TT>`basic.256'</TT>, CBM-II 256KiB BASIC (16KiB)

<LI>

<TT>`basic.500'</TT>, C510 BASIC (16KiB) (901236-02 + 901235-02)

<LI>

<TT>`chargen.500'</TT>, character generator ROM for the C5x0 (4KiB) (901225-01)

<LI>

<TT>`chargen.600'</TT>, character generator ROM for the C6x0 (4KiB)

<LI>

<TT>`chargen.700'</TT>, character generator ROM for the C7x0 (4KiB)

</UL>

<P>
The SCPU64 needs the following files:

</P>

<UL>

<LI>

<TT>`scpu64'</TT>, the SCPU64 ROM (128 KiB)

<LI>

<TT>`chargen'</TT>, the character generator ROM (4 KiB)

</UL>



<H2><A NAME="SEC27" HREF="vice_toc.html#TOC27">4.2  Keymap files</A></H2>

<P>
<EM>Keymap files</EM> are used to define the keyboard layout, defining which
key (or combination of keys) must be mapped to each keysym.

</P>
<P>
In other words, the keyboard emulation works like this: whenever the
user presses or releases a key while the emulation window has the input
focus, the emulator receives an event with a value that
identifies that key.  That value is called a <EM>keysym</EM> and is unique
to that key.  The emulator then looks up that keysym in an internal
table that tells it which key(s) to press or release on the emulated
keyboard.

</P>
<P>
This table is described by the keymap file, which is made up of lines
like the following:

</P>

<PRE>
KEYSYM ROW COLUMN SHIFTFLAG
</PRE>

<P>
Where:

</P>

<UL>

<LI>

<CODE>KEYSYM</CODE> is a string (GTK) or number (SDL) identifying the keysym: you can 
use the "show keycodes in statusbar" feature to see what keysym is bound to any key.

<LI>

<CODE>ROW</CODE> and <CODE>COLUMN</CODE> refer to the row and column of the emulated key on the
emulated keyboard - all existing keymaps have the respective keyboard matrix in
them in comments, have a look.

<LI>

<CODE>SHIFTFLAG</CODE> can have one of the following values. Flags can be combined by
 simply ORing (or adding) them together:

<TABLE BORDER>

<TR><TD><B>Value</B></TD>

<TD><B>Hex</B></TD>
<TD><B>Description</B></TD>
</TR>
<TR><TD><CODE>0</CODE></TD>

<TD><CODE>0x0000</CODE></TD>
<TD>the key is never shifted</TD>
</TR>
<TR><TD><CODE>1</CODE></TD>

<TD><CODE>0x0001</CODE></TD>
<TD>the key is shifted on the emulated keyboard, virtual shift will be used when</TD>
 it is not shifted on the host keyboard
</TR>
<TR><TD><CODE>2</CODE></TD>

<TD><CODE>0x0002</CODE></TD>
<TD>the key is the left shift key</TD>
</TR>
<TR><TD><CODE>4</CODE></TD>

<TD><CODE>0x0004</CODE></TD>
<TD>the key is the right shift key. Use only this flag for emulated keyboards</TD>
that have only one shift key.
</TR>
<TR><TD><CODE>8</CODE></TD>

<TD><CODE>0x0008</CODE></TD>
<TD>the key can be (optionally) shifted by the user.</TD>
</TR>
<TR><TD><CODE>16</CODE></TD>

<TD><CODE>0x0010</CODE></TD>
<TD>deshift key for this keysym/scancode. That means when the key is pressed with</TD>
 shift on the host keyboard, shift will <B>not</B> be used on the emulated keyboard.
</TR>
<TR><TD><CODE>32</CODE></TD>

<TD><CODE>0x0020</CODE></TD>
<TD>another definition for this keysym/scancode follows later in the file</TD>
</TR>
<TR><TD><CODE>64</CODE></TD>

<TD><CODE>0x0040</CODE></TD>
<TD>key is shift-lock on the emulated machine. Usually you'd use this for the caps</TD>
 lock key on the host keyboard.
</TR>
<TR><TD><CODE>128</CODE></TD>

<TD><CODE>0x0080</CODE></TD>
<TD>shift modifier required on host</TD>
</TR>
<TR><TD><CODE>256</CODE></TD>

<TD><CODE>0x0100</CODE></TD>
<TD>key is used for an alternative keyboard mapping, e.g. C64 mode in x128</TD>
</TR>
<TR><TD><CODE>512</CODE></TD>

<TD><CODE>0x0200</CODE></TD>
<TD>alt-r (alt-gr) modifier required on host</TD>
</TR>
<TR><TD><CODE>1024</CODE></TD>

<TD><CODE>0x0400</CODE></TD>
<TD>ctrl modifier required on host</TD>
</TR>
<TR><TD><CODE>2048</CODE></TD>

<TD><CODE>0x0800</CODE></TD>
<TD>key is combined with cbm for this keysym/scancode</TD>
</TR>
<TR><TD><CODE>4096</CODE></TD>

<TD><CODE>0x1000</CODE></TD>
<TD>key is combined with ctrl for this keysym/scancode</TD>
</TR>
<TR><TD><CODE>8192</CODE></TD>

<TD><CODE>0x2000</CODE></TD>
<TD>key is (left) cbm on emulated machine</TD>
</TR>
<TR><TD><CODE>16384</CODE></TD>

<TD><CODE>0x4000</CODE></TD>
<TD>key is (left) ctrl on emulated machine</TD>
</TR></TABLE>

</UL>

<P>
The <CODE>SHIFTFLAG</CODE> is useful if you want certain keys to be
"artificially" shifted by the emulator, and not by the user.  For
example, <KBD>F2</KBD> is shifted on the C64 keyboard, but you might want it
to be mapped to the unshifted <KBD>F2</KBD> key on the PC keyboard.  To do
so, you just have to use a line like the following:

</P>

<PRE>
F2 0 4 1
</PRE>

<P>
where <CODE>0</CODE> and <CODE>4</CODE> identify the key (row 0, column 4 on the
keyboard matrix), and <CODE>1</CODE> specifies that every time the user presses
<KBD>F2</KBD> the shift key on the C64 keyboard must be pressed.

</P>
<P>
There are also some special commands you can put into the keyboard file, these
 usually appear at the beginning of the file, before any actual keycode definitions;
they are recognized because they start with an exclamation mark:

</P>

<UL>

<LI>

<CODE>!CLEAR</CODE> clears the currently loaded keyboard map; it is
necessary to put this at the beginning of the file if you want the
keymap file to override all of the current internal settings;

<LI>

<CODE>!INCLUDE</CODE> followed by "filename" reads (inserts) file as mapping file. This is useful
when adding local mappings to an otherwise generic file (so you dont have to
copy the while file, but just add/modify a few keys).

<LI>

<CODE>!UNDEF</CODE> keysym'        remove keysym from table
</UL>


<UL>
<LI>

<CODE>!LSHIFT</CODE>, <CODE>!RSHIFT</CODE>, followed by a row and a column
value, specify where the left and right shift keys are located on the
emulated keyboard; for example, C64 default keymaps will specify


<PRE>
!LSHIFT 1 7
!RSHIFT 6 4
</PRE>

<LI>

<CODE>!VSHIFT</CODE>, followed by a shiftkey (RSHIFT or LSHIFT), specify what key will
be used as a virtual shift key when the shift flag is set.

<LI>

<CODE>!SHIFTL</CODE>, followed by a shiftkey (RSHIFT or LSHIFT), specify what key will
be used as a virtual shift-lock key; for example, C64 default keymaps will specify

<PRE>
!VSHIFT LSHIFT
!SHIFTL LSHIFT
</PRE>

</UL>

<P>
For emulated keyboards that have only one shift key, set both <CODE>!LSHIFT</CODE> and <CODE>!RSHIFT</CODE>
 to the same row/col and use RSHIFT for <CODE>!VSHIFT</CODE> and <CODE>!SHIFTL</CODE>.

</P>

<UL>
<LI>

<CODE>!LCTRL</CODE>, followed by a row and a column value, specifiy where the left 
control key is located on the emulated keyboard.

<LI>

<CODE>!LCBM</CODE>, followed by a row and a column value, specifiy where the left 
CBM key is located on the emulated keyboard.

<LI>

<CODE>!VCTRL</CODE>, followed by a ctrlkey (LCTRL), specify what key will
be used as a virtual control key.

<LI>

<CODE>!VCBM</CODE>, followed by a cbmkey (LCBM), specify what key will
be used as a virtual CBM key.

</UL>

<P>
Any line starting with the <CODE>#</CODE> sign, instead, is completely
ignored.  This is useful for adding comments within the keymap file.

</P>
<P>
VICE keymap files have the <TT>`.vkm'</TT> default extension, and every
emulator comes with a default positional mapping and a default symbolic
mapping, see section <A HREF="vice_2.html#SEC13">2.8  The keyboard emulation</A>.

</P>



<H2><A NAME="SEC28" HREF="vice_toc.html#TOC28">4.3  Palette files</A></H2>

<P>
<EM>Palette files</EM> are used to specify the colors used in the
emulators.  They are made up of lines like the following:

</P>

<PRE>
RED GREEN BLUE DITHER
</PRE>

<P>
where <CODE>RED</CODE>, <CODE>GREEN</CODE> and <CODE>BLUE</CODE> are hexadecimal values
ranging from 0 to FF and specifying the amount of red, green and blue
you want for each color and <CODE>DITHER</CODE> is a 4-bit hexadecimal number
specifying the pattern you want when rendering on a B/W display.

</P>
<P>
You have to include as many lines as the number of colors the emulated
machine has, and the order of the lines must respect the one used in the
machine (so the N'th line must contain the specifications for color N -
1 in the emulated machine).

</P>
<P>
Lines starting with the <CODE>#</CODE> sign are completely ignored.  This is
useful for adding comments (such as color names) within the palette
file.

</P>
<P>
For example, the default PET palette file (which has only two colors, 0 for
background and 1 for foreground), looks like the following:

</P>

<PRE>
#
# VICE Palette file
#
# Syntax:
# Red Green Blue Dither
#

# Background
00 00 00 0

# Foreground
00 FF 00 F
</PRE>



<H2><A NAME="SEC29" HREF="vice_toc.html#TOC29">4.4  Romset files</A></H2>

<P>
The Romset files are not used by default on all emulators.
You might have recognized that the names of the ROM images are
saved in resources. Loading a Romset file now just means a `shortcut'
to changing all the resources with ROM image names and reloading
the ROMs.

</P>
<P>
The PET and CBM-II emulators use this feature to change between the
different ROM versions available for those machines. E.g. the
Romset file for the PET 2001 is

</P>

<PRE>
KernalName="pet2001"
EditorName=
ChargenName="chargen"
RomModule9Name=
RomModuleAName=
RomModuleBName=
</PRE>

<P>
As you can see, the file even uses the same syntax as the
resource file, it is just a bit stripped down.

</P>
<P>
While a Romset file is processed, the directory where the Romset file
was found is temporarily prepended to the search path (<CODE>Directory</CODE>
resource). This also means that if you have a setting for
<CODE>Directory</CODE> in it, its effect is limited to the Romset file itself.

</P>


<H3><A NAME="SEC30" HREF="vice_toc.html#TOC30">4.4.1  Romset command line options</A></H3>

<DL COMPACT>

<DT><CODE>-romsetfile &#60;File&#62;</CODE>
<DD>
<A NAME="IDX49"></A>
 
load the given romset file

<A NAME="IDX50"></A>
<DT><CODE>-romsetarchive &#60;File&#62;</CODE>
<DD>
load the given romset archive

<A NAME="IDX51"></A>
<DT><CODE>-romsetarchiveselect &#60;Item number&#62;</CODE>
<DD>
select the given item from the current romset archive

</DL>



<H2><A NAME="SEC31" HREF="vice_toc.html#TOC31">4.5  Gtk3 Hotkeys files</A></H2>
<P>
<A NAME="gtk3-hotkeys-files"></A>
The Gtk3 port of VICE allows setting custom keyboard shortcuts, which we
refer to as hotkeys. These hotkeys can be set either through the user
interface or by editing hotkeys files, which are stored either in the
VICE data directory or in the user's VICE configuration directory.

</P>
<P>
VICE's hotkeys files are read from VICE's data directory, which we'll
refer to as <CODE>$VICEDIR</CODE> and the (optional) user's hotkeys will be in
the user's VICE configuration directory, which we'll refer to as
<CODE>$USERDIR</CODE>.

</P>
<P>
On Unix, <CODE>$VICEDIR</CODE> will point to <CODE>/usr/local/share/vice/</CODE>,
when using the default install prefix, and <CODE>$USERDIR</CODE> will point to
<CODE>$HOME/.config/vice/</CODE>. On Windows, <CODE>$VICEDIR</CODE> will point to
the root directory of the bindist and <CODE>$USERDIR</CODE> will point to
<CODE>%APPDATA%\vice</CODE>, which usually is
<CODE>C:\Users\%USERNAME%\AppData\Roaming\vice</CODE>.

</P>
<P>
A custom path can be specified by using the command line interface:
<CODE>x64sc -hotkeyfile &#60;some-file&#62;</CODE>, or by using the UI
(<STRONG>TODO</STRONG>).

</P>



<H2><A NAME="SEC32" HREF="vice_toc.html#TOC32">4.6  Syntax of the hotkeys files</A></H2>
<P>
<A NAME="syntax-of-the-hotkeys-files"></A>
The syntax of the hotkeys files is pretty straightforward, a file can
contain mappings, directives and comments. Leading and trailing
whitespace is ignored by the parser.

</P>



<H3><A NAME="SEC33" HREF="vice_toc.html#TOC33">4.6.1  Comments</A></H3>
<P>
<A NAME="comments"></A>
Comments are started with either <CODE>;</CODE> or <CODE>#</CODE> and occupy the
rest of the line, they can also appear inline after a directive or
mapping.

</P>
<P>
For example:

</P>

<PRE>
# This is a comment

monitor-open    &#60;Alt&#62;h      # This is an inline comment
</PRE>



<H3><A NAME="SEC34" HREF="vice_toc.html#TOC34">4.6.2  Directives</A></H3>
<P>
<A NAME="directives"></A>
Directives are special commands for the parser. They start with
<STRONG><CODE>!</CODE></STRONG> and are case-insensitive.

</P>



<H4><A NAME="SEC35" HREF="vice_toc.html#TOC35">4.6.2.1  !CLEAR</A></H4>
<P>
<A NAME="clear"></A>
Syntax

<BLOCKQUOTE>


<PRE>
!clear
</PRE>

</BLOCKQUOTE>

<P>
Clear all registered hotkeys. Best used as the first directive in the
(main) hotkeys file.

</P>


<H4><A NAME="SEC36" HREF="vice_toc.html#TOC36">4.6.2.2  !DEBUG</A></H4>
<P>
<A NAME="debug"></A>
Syntax

<BLOCKQUOTE>


<PRE>
!debug &#60;enable|disable|on|off&#62;
</PRE>

</BLOCKQUOTE>

<P>
Enable or disable debugging messages via VICE's log system. Messages
will be prefixed with 'Hotkeys:'. Debugging is disabled by default.

</P>


<H4><A NAME="SEC37" HREF="vice_toc.html#TOC37">4.6.2.3  !INCLUDE</A></H4>
<P>
<A NAME="include"></A>
Syntax

<BLOCKQUOTE>


<PRE>
!include &#60;file&#62;
</PRE>

</BLOCKQUOTE>

<P>
Process <CODE>&#60;file&#62;</CODE> as if its contents were injected into the current
file being processed. This can be used recursively. The <CODE>&#60;file&#62;</CODE>
argument can be inside quotes (<CODE>"</CODE>) to be able to use paths or
filenames with spaces in them, and quotes inside quotes can be used by
escaping them with <CODE>\</CODE>, for example:
<CODE>!include "foo \"bar\".vhk"</CODE>.
Special variables
As mentioned before, a few special variables exist to use in the
argument to the <CODE>!include</CODE> directive: <CODE>$VICEDIR</CODE> and
<CODE>$USERDIR</CODE>. These can be used to avoid hardcoded, absolute paths.

</P>
<P>
For example:

</P>

<PRE>
!include "$VICEDIR/common/gtk3-hotkeys-drive.vhk"
</PRE>

<P>
will include <CODE>/usr/local/share/vice/common/gtk3-hotkeys-drive.vhk</CODE>,
assuming the default install prefix for VICE was used.

</P>


<H4><A NAME="SEC38" HREF="vice_toc.html#TOC38">4.6.2.4  !UNDEF</A></H4>
<P>
<A NAME="undef"></A>
Syntax

<BLOCKQUOTE>


<PRE>
!undef [&#60;modifier&#62;..]&#60;keyname&#62;
</PRE>

</BLOCKQUOTE>

<P>
Remove a hotkey from whatever action it is mapped to.

</P>
<P>
For example:

</P>

<PRE>
!undef      &#60;Alt&#62;r      # Unmap Alt+r from 'restore display'
reset-soft  &#60;Alt&#62;r      # Map Alt+r to soft reset
</PRE>



<H3><A NAME="SEC39" HREF="vice_toc.html#TOC39">4.6.3  Hotkey mappings</A></H3>
<P>
<A NAME="hotkey-mappings"></A>

</P>



<H4><A NAME="SEC40" HREF="vice_toc.html#TOC40">4.6.3.1  Syntax</A></H4>
<P>
<A NAME="syntax-4"></A>

<BLOCKQUOTE>


<PRE>
&#60;action-name&#62;   [&#60;modifier&#62;...]&#60;keyname&#62;
</PRE>

</BLOCKQUOTE>

<P>
Create a mapping of a hotkey to an action, where <CODE>&#60;action-name&#62;</CODE> is
a string refering to an operation triggered by a menu item -- such as
toggling Warp Mode, or attaching a disk to a drive -- followed by a
keyname, optionally prefixed with one or more modifiers.

</P>
<P>
For example:

</P>

<PRE>
monitor-open    &#60;Alt&#62;m
settings-open   KP_Divide       # map '/' on the keypad to the settings dialog
edit-paste      &#60;Control&#62;&#60;Alt&#62;Insert
</PRE>

<P>
The key names are case-sensitive and map directly to the symbolic
constants GDK uses, but without the leading <CODE>GDK_KEY_</CODE> component.
In the above example the string 'Insert' would map to
<CODE>GDK_KEY_Insert</CODE>.

</P>
<P>
For a list of available symbolic key names, see the <CODE>gdkkeysyms.h</CODE>
header of the GDK development headers. On a Debian system the file is
located at <CODE>/usr/include/gtk-3.0/gdk/gdkkeysyms.h</CODE>. It can also be
viewed online at
<A HREF="https://gitlab.gnome.org/GNOME/gtk/blob/master/gdk/gdkkeysyms.h">https://gitlab.gnome.org/GNOME/gtk/blob/master/gdk/gdkkeysyms.h</A>

</P>


<H3><A NAME="SEC41" HREF="vice_toc.html#TOC41">4.6.4  List of modifiers</A></H3>
<TABLE BORDER>

<TR><TD></TD>

Windows/Unix
 @tab MacOS
 @tab GDK symbolic constant
</TR>
<TR><TD></TD>

<CODE>&#60;Alt&#62;</CODE>
 @tab <CODE>&#60;Option&#62;</CODE>
 @tab <CODE>GDK_MOD1_MASK</CODE>
</TR>
<TR><TD></TD>

<CODE>&#60;Control&#62;</CODE>
 @tab <CODE>&#60;Command&#62;</CODE>
 @tab <CODE>GDK_CONTROL_MASK</CODE>
</TR>
<TR><TD></TD>

<CODE>&#60;Hyper&#62;</CODE>
 @tab <CODE>GDK_HYPER_MASK</CODE>
</TR>
<TR><TD></TD>

<CODE>&#60;Shift&#62;</CODE>
 @tab <CODE>&#60;Shift&#62;</CODE>
 @tab <CODE>GDK_SHIFT_MASK</CODE>
</TR>
<TR><TD></TD>

<CODE>&#60;Super&#62;</CODE>
 @tab <CODE>&#60;Super&#62;</CODE>
 @tab <CODE>GDK_SUPER_MASK</CODE>
</TR></TABLE>


<BLOCKQUOTE>
<P>
Please be aware that some modifier+key combinations are either mapped to
the emulated machine's keyboard -- such as <CODE>&#60;Control&#62;1</CODE> being
mapped to CBM+1 when using a positional keymap -- or to the operating
system/window manager. Mappings using <CODE>&#60;Alt&#62;</CODE> or
<CODE>&#60;Alt&#62;&#60;Shift&#62;</CODE> are usually fine.
</BLOCKQUOTE>



<H3><A NAME="SEC42" HREF="vice_toc.html#TOC42">4.6.5  List of action names</A></H3>
<TABLE BORDER>

<TR><TD>name</TD>

 @tab description
</TR>
<TR><TD></TD>

<CODE>advance-frame</CODE>
 @tab Advance emulation one frame
</TR>
<TR><TD></TD>

<CODE>cart-attach</CODE>
 @tab Attach cartridge
</TR>
<TR><TD></TD>

<CODE>cart-detach</CODE>
 @tab Detach cartridge
</TR>
<TR><TD></TD>

<CODE>cart-freeze</CODE>
 @tab Press cartridge freeze button
</TR>
<TR><TD></TD>

<CODE>debug-autoplayback-frames</CODE>
 @tab Set autoplayback frames
</TR>
<TR><TD></TD>

<CODE>debug-core-dump-toggle</CODE>
 @tab Toggle saving core dump
</TR>
<TR><TD></TD>

<CODE>debug-trace-cpu-toggle</CODE>
 @tab Toggle CPU trace
</TR>
<TR><TD></TD>

<CODE>debug-trace-drive-10-toggle</CODE>
 @tab Toggle Drive 10 CPU trace
</TR>
<TR><TD></TD>

<CODE>debug-trace-drive-11-toggle</CODE>
 @tab Toggle Drive 11 CPU trace
</TR>
<TR><TD></TD>

<CODE>debug-trace-drive-8-toggle</CODE>
 @tab Toggle Drive 8 CPU trace
</TR>
<TR><TD></TD>

<CODE>debug-trace-drive-9-toggle</CODE>
 @tab Toggle Drive 9 CPU trace
</TR>
<TR><TD></TD>

<CODE>debug-trace-iec-toggle</CODE>
 @tab Toggle IEC bus trace
</TR>
<TR><TD></TD>

<CODE>drive-attach-8:1</CODE>
 @tab Attach disk to unit 8, drive 1
</TR>
<TR><TD></TD>

<CODE>drive-attach-9:0</CODE>
 @tab Attach disk to unit 9, drive 0
</TR>
<TR><TD></TD>

<CODE>drive-attach-9:1</CODE>
 @tab Attach disk to unit 9, drive 1
</TR>
<TR><TD></TD>

<CODE>drive-create</CODE>
 @tab Create and attach empty disk image
</TR>
<TR><TD></TD>

<CODE>drive-detach-10:0</CODE>
 @tab Detach disk from unit 10, drive 0
</TR>
<TR><TD></TD>

<CODE>drive-detach-10:1</CODE>
 @tab Detach disk from unit 10, drive 1
</TR>
<TR><TD></TD>

<CODE>drive-detach-11:0</CODE>
 @tab Detach disk from unit 11, drive 0
</TR>
<TR><TD></TD>

<CODE>drive-detach-11:1</CODE>
 @tab Detach disk from unit 11, drive 1
</TR>
<TR><TD></TD>

<CODE>drive-detach-8:0</CODE>
 @tab Detach disk from unit 8, drive 0
</TR>
<TR><TD></TD>

<CODE>drive-detach-8:1</CODE>
 @tab Detach disk from unit 8, drive 1
</TR>
<TR><TD></TD>

<CODE>drive-detach-9:0</CODE>
 @tab Detach disk from unit 9, drive 0
</TR>
<TR><TD></TD>

<CODE>drive-detach-9:1</CODE>
 @tab Detach disk from unit 9, drive 1
</TR>
<TR><TD></TD>

<CODE>drive-detach-all</CODE>
 @tab Detach all disks
</TR>
<TR><TD></TD>

<CODE>edit-copy</CODE>
 @tab Copy screen content to clipboard
</TR>
<TR><TD></TD>

<CODE>edit-paste</CODE>
 @tab Paste clipboard content into machine
</TR>
<TR><TD></TD>

<CODE>fliplist-add</CODE>
 @tab Add current disk to fliplist
</TR>
<TR><TD></TD>

<CODE>fliplist-clear</CODE>
 @tab Clear fliplist
</TR>
<TR><TD></TD>

<CODE>fliplist-load</CODE>
 @tab Load fliplist
</TR>
<TR><TD></TD>

<CODE>fliplist-next</CODE>
 @tab Attach next disk in fliplist
</TR>
<TR><TD></TD>

<CODE>fliplist-previous</CODE>
 @tab Attach previous disk in fliplist
</TR>
<TR><TD></TD>

<CODE>fliplist-remove</CODE>
 @tab Remove current disk from fliplist
</TR>
<TR><TD></TD>

<CODE>fliplist-save</CODE>
 @tab Save fliplist
</TR>
<TR><TD></TD>

<CODE>fullscreen-decorations-toggle</CODE>
 @tab Show menu/status in fullscreen
</TR>
<TR><TD></TD>

<CODE>fullscreen-toggle</CODE>
 @tab Toggle fullscreen
</TR>
<TR><TD></TD>

<CODE>help-about</CODE>
 @tab Show about dialog
</TR>
<TR><TD></TD>

<CODE>help-command-line</CODE>
 @tab Command line options
</TR>
<TR><TD></TD>

<CODE>help-compile-time</CODE>
 @tab Compile time features
</TR>
<TR><TD></TD>

<CODE>help-hotkeys</CODE>
 @tab Hotkeys
</TR>
<TR><TD></TD>

<CODE>help-manual</CODE>
 @tab Browse VICE manual
</TR>
<TR><TD></TD>

<CODE>history-milestone-reset</CODE>
 @tab Return to recording milestone
</TR>
<TR><TD></TD>

<CODE>history-milestone-set</CODE>
 @tab Set recording milestone
</TR>
<TR><TD></TD>

<CODE>history-playback-start</CODE>
 @tab Start playing back events
</TR>
<TR><TD></TD>

<CODE>history-playback-stop</CODE>
 @tab Stop playing back events
</TR>
<TR><TD></TD>

<CODE>history-record-start</CODE>
 @tab Start recording events
</TR>
<TR><TD></TD>

<CODE>history-record-stop</CODE>
 @tab Stop recording events
</TR>
<TR><TD></TD>

<CODE>keyset-joystick-enable</CODE>
 @tab Allow keyset joystick
</TR>
<TR><TD></TD>

<CODE>media-record</CODE>
 @tab Record media
</TR>
<TR><TD></TD>

<CODE>media-stop</CODE>
 @tab Stop media recording
</TR>
<TR><TD></TD>

<CODE>monitor-open</CODE>
 @tab Open monitor
</TR>
<TR><TD></TD>

<CODE>mouse-grab-toggle</CODE>
 @tab Toggle Mouse Grab
</TR>
<TR><TD></TD>

<CODE>pause-toggle</CODE>
 @tab Toggle Pause
</TR>
<TR><TD></TD>

<CODE>quit</CODE>
 @tab Quit emulator
</TR>
<TR><TD></TD>

<CODE>reset-drive-10</CODE>
 @tab Reset drive 10
</TR>
<TR><TD></TD>

<CODE>reset-drive-11</CODE>
 @tab Reset drive 11
</TR>
<TR><TD></TD>

<CODE>reset-drive-8</CODE>
 @tab Reset drive 8
</TR>
<TR><TD></TD>

<CODE>reset-drive-9</CODE>
 @tab Reset drive 9
</TR>
<TR><TD></TD>

<CODE>reset-hard</CODE>
 @tab Hard reset the machine
</TR>
<TR><TD></TD>

<CODE>reset-soft</CODE>
 @tab Soft reset the machine
</TR>
<TR><TD></TD>

<CODE>restore-display</CODE>
 @tab Resize application window to fit contents
</TR>
<TR><TD></TD>

<CODE>screenshot-quicksave</CODE>
 @tab Save screenshot in current working directory
</TR>
<TR><TD></TD>

<CODE>settings-default</CODE>
 @tab Restore default settings
</TR>
<TR><TD></TD>

<CODE>settings-dialog</CODE>
 @tab Open settings dialog
</TR>
<TR><TD></TD>

<CODE>settings-load</CODE>
 @tab Load settings
</TR>
<TR><TD></TD>

<CODE>settings-load-extra</CODE>
 @tab Load additional settings
</TR>
<TR><TD></TD>

<CODE>settings-load-from</CODE>
 @tab Load settings from alternate file
</TR>
<TR><TD></TD>

<CODE>settings-save</CODE>
 @tab Save settings
</TR>
<TR><TD></TD>

<CODE>settings-save-to</CODE>
 @tab Save settings to alternate file
</TR>
<TR><TD></TD>

<CODE>smart-attach</CODE>
 @tab Attach a medium to the emulator inspecting its type
</TR>
<TR><TD></TD>

<CODE>snapshot-load</CODE>
 @tab Load snapshot file
</TR>
<TR><TD></TD>

<CODE>snapshot-quickload</CODE>
 @tab Quickload snapshot
</TR>
<TR><TD></TD>

<CODE>snapshot-quicksave</CODE>
 @tab Quicksave snapshot
</TR>
<TR><TD></TD>

<CODE>snapshot-save</CODE>
 @tab Save snapshot file
</TR>
<TR><TD></TD>

<CODE>swap-controlport-toggle</CODE>
 @tab Swap controlport joysticks
</TR>
<TR><TD></TD>

<CODE>tape-attach-1</CODE>
 @tab Attach tape to datasette 1
</TR>
<TR><TD></TD>

<CODE>tape-attach-2</CODE>
 @tab Attach tape to datasette 2
</TR>
<TR><TD></TD>

<CODE>tape-create-1</CODE>
 @tab Create tape and attach to datasette 1
</TR>
<TR><TD></TD>

<CODE>tape-create-2</CODE>
 @tab Create tape and attach to datasette 2
</TR>
<TR><TD></TD>

<CODE>tape-detach-1</CODE>
 @tab Detach tape from datasette 1
</TR>
<TR><TD></TD>

<CODE>tape-detach-2</CODE>
 @tab Detach tape from datasette 2
</TR>
<TR><TD></TD>

<CODE>tape-ffwd-1</CODE>
 @tab Press FFWD on datasette 1
</TR>
<TR><TD></TD>

<CODE>tape-ffwd-2</CODE>
 @tab Press FFWD on datasette 2
</TR>
<TR><TD></TD>

<CODE>tape-play-1</CODE>
 @tab Press PLAY on datasette 1
</TR>
<TR><TD></TD>

<CODE>tape-play-2</CODE>
 @tab Press PLAY on datasette 2
</TR>
<TR><TD></TD>

<CODE>tape-record-1</CODE>
 @tab Press RECORD on datasette 1
</TR>
<TR><TD></TD>

<CODE>tape-record-2</CODE>
 @tab Press RECORD on datasette 2
</TR>
<TR><TD></TD>

<CODE>tape-reset-1</CODE>
 @tab Reset datasette 1
</TR>
<TR><TD></TD>

<CODE>tape-reset-1</CODE>
 @tab Reset datasette 2
</TR>
<TR><TD></TD>

<CODE>tape-reset-counter-1</CODE>
 @tab Reset datasette 1 counter
</TR>
<TR><TD></TD>

<CODE>tape-reset-counter-2</CODE>
 @tab Reset datasette 2 counter
</TR>
<TR><TD></TD>

<CODE>tape-rewind-1</CODE>
 @tab Press REWIND on datasette 1
</TR>
<TR><TD></TD>

<CODE>tape-rewind-2</CODE>
 @tab Press REWIND on datasette 2
</TR>
<TR><TD></TD>

<CODE>tape-stop-1</CODE>
 @tab Press STOP on datasette 1
</TR>
<TR><TD></TD>

<CODE>tape-stop-2</CODE>
 @tab Press STOP on datasette 2
</TR>
<TR><TD></TD>

<CODE>warp-mode-toggle</CODE>
 @tab Toggle Warp Mode
</TR></TABLE>

<P>
To see which emulators support which actions please look at
<CODE>doc/gtk3-hotkeys.md</CODE> or <CODE>src/arch/gtk3/uiactions.h</CODE>.

</P>


<H3><A NAME="SEC43" HREF="vice_toc.html#TOC43">4.6.6  Syntax highlighting</A></H3>
<P>
<A NAME="syntax-highlighting"></A>
Vim syntax highlighting files can be found in doc/vim/. Currently there
are two files: <CODE>syntax/vhk.vim</CODE> and <CODE>ftdetect/vhk.vim</CODE>, these
can be copied to <CODE>$VIMFILES/</CODE> to enable hotkeys syntax highlighting
in Vim.

</P>

<P><HR><P>
Go to the <A HREF="vice_1.html">first</A>, <A HREF="vice_3.html">previous</A>, <A HREF="vice_5.html">next</A>, <A HREF="vice_23.html">last</A> section, <A HREF="vice_toc.html">table of contents</A>.
</BODY>
</HTML>
